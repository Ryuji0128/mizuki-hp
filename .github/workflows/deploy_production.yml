name: Deploy_Production

on:
  pull_request:
    branches:
      - main
    types: [closed]
  workflow_dispatch:

concurrency:
  group: deploy-production
  cancel-in-progress: true

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ryuji0128/mizuki-hp

jobs:
  build-and-push:
    if: github.event_name == 'workflow_dispatch' || (github.event.pull_request.merged == true && github.event.pull_request.base.ref == 'main')
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2

      - name: Setup Node.js
        uses: actions/setup-node@1e60f620b9541d16bece96c5465dc8ee9832be0b # v4.1.0
        with:
          node-version: '20'
          cache: 'yarn'
          cache-dependency-path: next/yarn.lock

      - name: Install dependencies
        working-directory: ./next
        run: yarn install --frozen-lockfile

      - name: Run lint
        working-directory: ./next
        run: yarn lint

      - name: Log in to Container Registry
        uses: docker/login-action@9780b0c442fbb1117ed29e0efdff1e18412f7567 # v3.3.0
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@c47758b77c9736f4b2ef4073d4d51994fabfe349 # v3.7.1

      - name: Build and push Docker image
        uses: docker/build-push-action@4f58ea79222b3b9dc2c8bbdd6debcef730109a75 # v6.9.0
        with:
          context: ./next
          push: true
          tags: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  deploy:
    needs: build-and-push
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: read

    steps:
      - name: Deploy to Production Server
        uses: appleboy/ssh-action@0ff4204d59e8e51228ff73bce53f80d53301dee2 # v1.2.5
        env:
          GH_PAT: ${{ secrets.GH_PAT }}
          GH_USERNAME: ${{ secrets.GH_USERNAME }}
          IMAGE_TAG: ${{ github.sha }}
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USERNAME }}
          key: ${{ secrets.SSH_SECRET_KEY }}
          port: ${{ secrets.SSH_PORT }}
          command_timeout: 10m
          envs: GH_PAT,GH_USERNAME,IMAGE_TAG
          script: |
            set -e

            echo "Deploying mizuki-hp..."

            cd ~/mizuki-hp

            echo "Pulling latest code..."
            git fetch origin main
            git checkout main
            # WARNING: This will discard ALL local changes on the server
            # If you have manual edits on the server, they will be lost
            # Reset to remote state if local changes exist
            git reset --hard origin/main

            echo "Logging in to GitHub Container Registry..."
            echo "${GH_PAT}" | docker login ghcr.io -u "${GH_USERNAME}" --password-stdin

            echo "Pulling image for tag: ${IMAGE_TAG}"
            export IMAGE_TAG="${IMAGE_TAG}"
            docker compose -f docker-compose.yml pull next

            echo "Starting mysql first..."
            docker compose -f docker-compose.yml up -d mysql

            echo "Waiting for MySQL to be ready..."
            i=1
            MYSQL_READY=false
            while [ $i -le 30 ]; do
              # Use container's MYSQL_ROOT_PASSWORD environment variable
              if docker compose -f docker-compose.yml exec -T mysql sh -c 'mysqladmin ping -h localhost -u root -p${MYSQL_ROOT_PASSWORD} --silent' 2>/dev/null; then
                echo "MySQL is ready!"
                MYSQL_READY=true
                break
              fi
              echo "Waiting for MySQL... ($i/30)"
              sleep 2
              i=$((i+1))
            done

            if [ "$MYSQL_READY" = "false" ]; then
              echo "ERROR: MySQL failed to become ready after 60 seconds"
              exit 1
            fi

            echo "Running database migrations..."
            if ! docker compose -f docker-compose.yml run --rm next node node_modules/prisma/build/index.js migrate deploy; then
              echo "ERROR: Database migration failed"
              exit 1
            fi
            echo "Database migrations completed successfully"

            echo "Starting app containers..."
            docker compose -f docker-compose.yml up -d next nginx

            echo "Checking SSL certificate..."
            CERT_PATH="./certbot/conf/live/mizuki-clinic.jp/fullchain.pem"
            if [ ! -f "$CERT_PATH" ]; then
              echo "SSL certificate not found. Obtaining certificate..."
              if docker compose --profile ssl -f docker-compose.yml run --rm certbot; then
                echo "SSL certificate obtained successfully. Restarting nginx with SSL..."
                docker compose -f docker-compose.yml restart nginx
              else
                echo "WARNING: SSL certificate acquisition failed. Nginx will continue with HTTP only."
                echo "Check DNS settings and ensure port 80 is accessible."
              fi
            else
              echo "SSL certificate exists. Checking for renewal..."
              docker compose --profile ssl -f docker-compose.yml run --rm certbot renew --quiet || true
              docker compose -f docker-compose.yml restart nginx
            fi

            echo "Cleaning up old images..."
            docker image prune -f

            echo "Deployment completed successfully!"
